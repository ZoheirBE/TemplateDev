{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,QAAQ,IAAI,+BAA+B;AAM3C,QAAQ,IAAI,mCAAmC;AAG/C,IAAI,CAAC,QAAQ,MAAM;AACjB,UAAQ,IAAI,qCAAqC;AACjD,UAAQ,KAAK,CAAC;AAChB;AAEA,MAAM,OAAO,YAAY;AACnB;AAEF,UAAM,EAAE,cAAAA,cAAA,IAAiB,MAAM;AAAA,4BAAAA,cAAA;AAAsB,6BAAAA,cAAA;AAAA;AAIvC;AAAA,MACZ;AAAA,MAAO;AAAA,QACL,MAAM,CAAC,SAAqB,SAAc;AAElC,gCAAgB,OAAO,OAAOA,aAAY;AAC5C,4BAAc,SAAS,OAAO,GAAG;AACvB,6BAAK,SAAS,IAAI;AAAA;AAAA,QAElC;AAAA,QACA,SAAS,CAAC,SAAqB,SAAmC;AAC1D,gCAAgB,OAAO,OAAOA,aAAY;AAC5C,4BAAc,SAAS,OAAO,GAAG;AAEvB,2BAAG,SAAS,CAAC,UAAU,SAAS,KAAK,GAAG,IAAI,CAAC;AAAA;AAAA,QAE7D;AAAA,QACA,QAAQ,OAAO,SAAqB,SAAc;AAC1C,gCAAgB,OAAO,OAAOA,aAAY;AAC5C,4BAAc,SAAS,OAAO,GAAG;AACnC,mBAAO,MAAM,YAAY,OAAO,SAAS,IAAI;AAAA;AAExC;AAAA;AAAA,MACT;AAAA,IAEJ;AAEA,YAAQ,IAAI,oCAAoC;AAAA,WACzC,OAAO;AACN,kBAAM,iCAAiC,KAAK;AAAA;AAExD;AAEA,KAAK;ACpDE,MAAM,eAAe;AAAA,EAC1B,WAAW;AAAA,EACX,WAAW;AAAA,EACX,YAAY;AACd","names":["IPC_CHANNELS"],"ignoreList":[],"sources":["../../src/preload/index.ts","../../src/shared/ipc.ts"],"sourcesContent":["console.log('ðŸ”Œ Preload script starting...');\n\n// @ts-ignore\nimport { contextBridge, ipcRenderer } from 'electron';\nimport { type IPC_CHANNELS, type IpcChannel } from '../shared/ipc';\n\nconsole.log('[Preload] Starting preload script');\n\n// Check if we're in a renderer process\nif (!process.type) {\n  console.log('[Preload] Not in a renderer process');\n  process.exit(1);\n}\n\nconst init = async () => {\n  try {\n    // Get IPC channels\n    const { IPC_CHANNELS } = await import('../shared/ipc');\n\n    // Expose protected methods that allow the renderer process to use\n    // the ipcRenderer without exposing the entire object\n    contextBridge.exposeInMainWorld(\n      'api', {\n        send: (channel: IpcChannel, data: any) => {\n          // whitelist channels\n          const validChannels = Object.values(IPC_CHANNELS);\n          if (validChannels.includes(channel)) {\n            ipcRenderer.send(channel, data);\n          }\n        },\n        receive: (channel: IpcChannel, func: (...args: any[]) => void) => {\n          const validChannels = Object.values(IPC_CHANNELS);\n          if (validChannels.includes(channel)) {\n            // Deliberately strip event as it includes `sender` \n            ipcRenderer.on(channel, (event, ...args) => func(...args));\n          }\n        },\n        invoke: async (channel: IpcChannel, data: any) => {\n          const validChannels = Object.values(IPC_CHANNELS);\n          if (validChannels.includes(channel)) {\n            return await ipcRenderer.invoke(channel, data);\n          }\n          return null;\n        }\n      }\n    );\n\n    console.log('[Preload] API exposed successfully');\n  } catch (error) {\n    console.error('[Preload] Error initializing:', error);\n  }\n};\n\ninit();\n","/** IPC channel names */\nexport const IPC_CHANNELS = {\n  FILE_OPEN: 'file:open',\n  FILE_READ: 'file:read',\n  FILE_WRITE: 'file:write'\n} as const;\n\nexport type IpcChannel = typeof IPC_CHANNELS[keyof typeof IPC_CHANNELS];\n\n/** File open message payload */\nexport interface FileOpenMessage {\n  filePath: string;\n}\n\n/** File read message payload */\nexport interface FileReadMessage {\n  filePath: string;\n}\n\n/** File read response payload */\nexport interface FileReadResponse {\n  content: string;\n  error?: string;\n}\n\n/** File write message payload */\nexport interface FileWriteMessage {\n  filePath: string;\n  content: string;\n}\n\n/** File write response payload */\nexport interface FileWriteResponse {\n  success: boolean;\n  error?: string;\n}\n"],"file":"index.mjs"}